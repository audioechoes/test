<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Tamabrickchi</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    body {
      margin: 0;
      background: white;
      color: black;
      font-family: monospace;
      text-align: center;
      touch-action: none;
    }
    canvas {
      background: white;
      display: block;
      margin: 20px auto;
      border: 1px solid black;
      touch-action: none;
    }
    #restartBtn, #startBtn, #fullscreenBtn {
      display: none;
      font-family: monospace;
      font-size: 20px;
      padding: 10px 20px;
      border: 1px solid black;
      background: white;
      cursor: pointer;
      margin: 20px auto;
    }
    #instructions {
      font-family: monospace;
      padding: 10px;
      max-width: 600px;
      margin: 20px auto;
      display: block;
    }
  </style>
</head>
<body>
  <div style="display: flex; flex-direction: column; align-items: center;">
    <h1>Tamabrickchi</h1>
    <div id="instructions">
      <p>Use <strong>Left/Right Arrows</strong> to move the paddle.</p>
      <p>Press <strong>Spacebar</strong> to launch the ball.</p>
      <p>Break all words. Timer increases +1s on successful hit.</p>
      <p>Game over if the ball is missed.</p>
      <button id="startBtn">Start Game</button>
    </div>
    <canvas id="gameCanvas"></canvas>
    <button id="fullscreenBtn">Fullscreen</button>
    <button id="restartBtn" onclick="location.reload()">Restart</button>
  </div>

  <script>
    class Paddle {
      constructor(canvas) {
        this.canvas = canvas;
        this.width = 100;
        this.height = 10;
        this.x = canvas.width / 2 - this.width / 2;
        this.y = canvas.height - 20;
        this.speed = 6;
        this.dx = 0;
      }

      move() {
        this.x += this.dx;
        if (this.x < 0) this.x = 0;
        if (this.x + this.width > this.canvas.width) this.x = this.canvas.width - this.width;
      }

      draw(ctx) {
        ctx.fillRect(this.x, this.y, this.width, this.height);
      }
    }

    class Ball {
      constructor(canvas) {
        this.canvas = canvas;
        this.radius = 8;
        this.reset();
      }

      reset() {
        this.x = this.canvas.width / 2;
        this.y = this.canvas.height - 30;
        this.dx = 4;
        this.dy = -4;
        this.moving = false;
      }

      move() {
        if (!this.moving) return;
        this.x += this.dx;
        this.y += this.dy;

        if (this.x < this.radius || this.x > this.canvas.width - this.radius) this.dx *= -1;
        if (this.y < this.radius) this.dy *= -1;
      }

      draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      }
    }

    class WordBlock {
      constructor(x, y, type) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.destroyed = false;
      }

      draw(ctx, width, height) {
        if (this.destroyed) return;
        ctx.strokeRect(this.x, this.y, width, height);
        ctx.strokeText(this.type, this.x + width / 2, this.y + height / 2);
      }
    }

    class Game {
      constructor() {
        this.canvas = document.getElementById("gameCanvas");
        this.ctx = this.canvas.getContext("2d");
        this.paddle = new Paddle(this.canvas);
        this.ball = new Ball(this.canvas);
        this.wordTypes = ["audio", "echoes"];
        this.wordWidth = 80;
        this.wordHeight = 30;
        this.hMargin = 60;
        this.vMargin = 50;
        this.wordSpacingX = 10;
        this.wordSpacingY = 20;
        this.rows = 3;
        this.cols = 0;
        this.words = [];
        this.score = 0;
        this.timer = 60;
        this.timerInterval = null;
        this.gameOver = false;
        this.setup();
      }

      setup() {
        this.resizeCanvas();
        this.createWords();
        this.addEventListeners();
      }

      resizeCanvas() {
        const width = window.innerWidth > 768 ? window.innerWidth * 0.9 : window.innerWidth;
        const height = window.innerHeight > 768 ? window.innerHeight * 0.6 : window.innerHeight * 0.85;
        this.canvas.width = Math.min(1400, width);
        this.canvas.height = Math.floor(this.canvas.width / 2);
      }

      createWords() {
        this.words = [];
        this.cols = Math.floor((this.canvas.width - 2 * this.hMargin) / (this.wordWidth + this.wordSpacingX));
        const offsetX = (this.canvas.width - (this.cols * (this.wordWidth + this.wordSpacingX))) / 2;
        for (let row = 0; row < this.rows; row++) {
          for (let col = 0; col < this.cols; col++) {
            const x = offsetX + col * (this.wordWidth + this.wordSpacingX);
            const y = this.vMargin + row * (this.wordHeight + this.wordSpacingY);
            const type = this.wordTypes[Math.floor(Math.random() * this.wordTypes.length)];
            this.words.push(new WordBlock(x, y, type));
          }
        }
      }

      drawTimer() {
        this.ctx.font = "20px monospace";
        this.ctx.fillStyle = "black";
        this.ctx.fillText(`Time: ${this.timer}s`, this.canvas.width - 100, 20);
      }

      update() {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.paddle.move();
        this.ball.move();
        this.checkCollisions();
        this.paddle.draw(this.ctx);
        this.ball.draw(this.ctx);
        this.words.forEach(word => word.draw(this.ctx, this.wordWidth, this.wordHeight));
        this.drawTimer();
      }

      checkCollisions() {
        if (
          this.ball.x > this.paddle.x &&
          this.ball.x < this.paddle.x + this.paddle.width &&
          this.ball.y + this.ball.radius > this.paddle.y
        ) {
          this.ball.dy *= -1;
          this.ball.y = this.paddle.y - this.ball.radius;
          this.timer += 1;
        }

        for (let word of this.words) {
          if (!word.destroyed &&
              this.ball.x > word.x && this.ball.x < word.x + this.wordWidth &&
              this.ball.y - this.ball.radius < word.y + this.wordHeight && this.ball.y + this.ball.radius > word.y) {
            word.destroyed = true;
            this.ball.dy *= -1;
            this.score++;
          }
        }

        if (this.words.every(w => w.destroyed)) {
          this.winGame();
        }

        if (this.ball.y > this.canvas.height) {
          this.endGame();
        }
      }

      start() {
        this.gameOver = false;
        this.ball.reset();
        this.timer = 60;
        this.createWords();
        this.timerInterval = setInterval(() => {
          if (this.timer > 0 && !this.gameOver) this.timer--;
          else this.endGame();
        }, 1000);
        this.loop();
      }

      loop() {
        if (this.gameOver) return;
        this.update();
        requestAnimationFrame(() => this.loop());
      }

      endGame() {
        this.gameOver = true;
        clearInterval(this.timerInterval);
        this.ctx.font = "40px monospace";
        this.ctx.fillText("GAME OVER", this.canvas.width / 2, this.canvas.height / 2);
        document.getElementById("restartBtn").style.display = "inline-block";
      }

      winGame() {
        this.gameOver = true;
        clearInterval(this.timerInterval);
        this.ctx.font = "40px monospace";
        this.ctx.fillStyle = "green";
        this.ctx.fillText("YOU WIN!", this.canvas.width / 2, this.canvas.height / 2);
        document.getElementById("restartBtn").style.display = "inline-block";
      }

      addEventListeners() {
        window.addEventListener("resize", () => this.resizeCanvas());

        document.addEventListener("keydown", e => {
          if (e.key === "ArrowLeft") this.paddle.dx = -this.paddle.speed;
          if (e.key === "ArrowRight") this.paddle.dx = this.paddle.speed;
          if (e.code === "Space" && !this.ball.moving && !this.gameOver) {
            this.ball.moving = true;
          }
        });

        document.addEventListener("keyup", e => {
          if (e.key === "ArrowLeft" || e.key === "ArrowRight") this.paddle.dx = 0;
        });

        this.canvas.addEventListener("touchstart", e => {
          const middle = window.innerWidth / 2;
          const touchX = e.touches[0].clientX;
          this.paddle.dx = touchX < middle ? -this.paddle.speed : this.paddle.speed;
        });

        this.canvas.addEventListener("touchend", () => this.paddle.dx = 0);

        document.getElementById("fullscreenBtn").onclick = () => {
          if (!document.fullscreenElement) this.canvas.requestFullscreen?.();
          else document.exitFullscreen?.();
        };
      }
    }

    window.onload = () => {
      const game = new Game();
      document.getElementById("startBtn").onclick = () => {
        document.getElementById("instructions").style.display = "none";
        document.getElementById("fullscreenBtn").style.display = "inline-block";
        game.start();
      };
    };
  </script>
</body>
</html>
