<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Breaking Out for the Summer</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: white;
      color: black;
      overflow: hidden;
      font-family: monospace;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    canvas {
      background: white;
      border: 2px solid black;
      max-width: 100vw;
      max-height: 100vh;
      width: 100%;
      height: auto;
    }
    #endScreen, #overlayText {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      background: rgba(255, 255, 255, 0.85);
      z-index: 10;
    }
    #overlayText {
      font-size: 36px;
      pointer-events: none;
      background: none;
    }
    .game-btn {
      font-size: 20px;
      padding: 10px 20px;
      cursor: pointer;
      margin-top: 20px;
      font-family: monospace;
    }
  </style>
</head>
<body>
  <div id="endScreen" style="display: none;">
    <h1>Game Over</h1>
    <p id="finalScore"></p>
    <button class="game-btn" onclick="location.reload()">Play Again</button>
  </div>
  <div id="overlayText"></div>
  <div id="startScreen" style="position:absolute;top:0;left:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;background:white;z-index:10;font-size:28px;font-family:monospace;cursor:pointer;">
    Click to Start
  </div>
  <canvas id="gameCanvas" tabindex="0"></canvas>

  <script>
    const DESIGN_WIDTH = 1000;
    const DESIGN_HEIGHT = 600;

    const brick = { rowCount: 5, columnCount: 10, width: 90, height: 30, padding: 10, offsetTop: 50, offsetLeft: 40 };
    let canvas, ctx, WIDTH, HEIGHT;

    function resizeCanvas() {
      canvas = document.getElementById('gameCanvas');
      ctx = canvas.getContext('2d');
      const parentWidth = window.innerWidth;
      const parentHeight = window.innerHeight;
      const scale = Math.min(parentWidth / DESIGN_WIDTH, parentHeight / DESIGN_HEIGHT);

      WIDTH = DESIGN_WIDTH * scale;
      HEIGHT = DESIGN_HEIGHT * scale;

      canvas.width = WIDTH;
      canvas.height = HEIGHT;

      brick.columnCount = Math.floor((WIDTH - brick.offsetLeft * 2) / (brick.width + brick.padding));
      brick.width = (WIDTH - brick.offsetLeft * 2 - brick.padding * (brick.columnCount - 1)) / brick.columnCount;
    }

    resizeCanvas();
    window.addEventListener('resize', () => {
      resizeCanvas();
      location.reload();
    });

    const paddle = { width: 150, height: 20, x: 0, y: 0, speed: 10, dx: 0 };
    const ball = { x: 0, y: 0, radius: 10, speed: 6, dx: 6, dy: -6 };
    const overlayText = document.getElementById('overlayText');

    let bricks = [], particles = [], floatingTexts = [];
    let lives = 5, lostLifeTick = 0, lastBonusScore = 0;
    let score = 0, level = 1;
    const maxLevel = 3;
    let isPaused = false, gameStarted = false, gameOver = false;

    function createBricks() {
      bricks = [];
      for (let r = 0; r < brick.rowCount; r++) {
        bricks[r] = [];
        for (let c = 0; c < brick.columnCount; c++) {
          bricks[r][c] = { x: 0, y: 0, visible: true };
        }
      }
    }

    function drawPaddle() {
      ctx.fillStyle = 'black';
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);
    }

    function drawBall() {
      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fillStyle = 'black';
      ctx.fill();
      ctx.closePath();
    }

    function drawBricks() {
      bricks.forEach((row, rIdx) => {
        row.forEach((b, cIdx) => {
          if (b.visible) {
            const x = cIdx * (brick.width + brick.padding) + brick.offsetLeft;
            const y = rIdx * (brick.height + brick.padding) + brick.offsetTop;
            b.x = x;
            b.y = y;
            ctx.fillStyle = 'black';
            ctx.fillRect(x, y, brick.width, brick.height);
          }
        });
      });
    }

    function drawScore() {
      ctx.fillStyle = 'black';
      ctx.font = '20px monospace';
      ctx.fillText(`Score: ${score}`, 20, 30);
      ctx.fillText(`Level: ${level}`, WIDTH - 120, 30);
      drawLives();
    }

    function drawLives() {
      ctx.font = lostLifeTick > 0 ? '26px monospace' : '20px monospace';
      ctx.fillStyle = 'black';
      ctx.fillText('Lives: ' + 'ðŸ–¤'.repeat(lives), WIDTH / 2 - 50, 30);
      if (lostLifeTick > 0) lostLifeTick--;
    }

    function movePaddle() {
      paddle.x += paddle.dx;
      if (paddle.x < 0) paddle.x = 0;
      if (paddle.x + paddle.width > WIDTH) paddle.x = WIDTH - paddle.width;
    }

    function spawnParticles(x, y) {
      for (let i = 0; i < 10; i++) {
        particles.push({ x, y, dx: (Math.random() - 0.5) * 4, dy: (Math.random() - 0.5) * 4, life: 30 });
      }
    }

    function updateParticles() {
      particles.forEach(p => {
        p.x += p.dx;
        p.y += p.dy;
        p.life--;
      });
      particles = particles.filter(p => p.life > 0);
    }

    function drawParticles() {
      ctx.fillStyle = 'black';
      particles.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fill();
      });
    }

    function moveBall() {
      ball.x += ball.dx;
      ball.y += ball.dy;

      if (ball.x - ball.radius < 0 || ball.x + ball.radius > WIDTH) ball.dx *= -1;
      if (ball.y - ball.radius < 0) ball.dy *= -1;

      if (ball.x > paddle.x && ball.x < paddle.x + paddle.width && ball.y + ball.radius > paddle.y) {
        ball.dy *= -1;
        ball.y = paddle.y - ball.radius;
        spawnParticles(ball.x, ball.y);
      }

      bricks.forEach(row => {
        row.forEach(b => {
          if (b.visible) {
            if (ball.x > b.x && ball.x < b.x + brick.width && ball.y > b.y && ball.y < b.y + brick.height) {
              ball.dy *= -1;
              b.visible = false;
              score += 10;
              if (score - lastBonusScore >= 100 && lives < 5) {
                lives++;
                lastBonusScore = score;
                floatingTexts.push({ text: '+1 ðŸ–¤', x: ball.x, y: ball.y, alpha: 1 });
              }
              spawnParticles(ball.x, ball.y);
            }
          }
        });
      });

      if (ball.y + ball.radius > HEIGHT) {
        lives--;
        lostLifeTick = 20;
        floatingTexts.push({ text: 'ðŸ–¤', x: ball.x, y: ball.y, alpha: 1, shatter: true });
        if (lives > 0) {
          resetBallAndPaddle();
        } else {
          endGame();
        }
      }

      const allBricksCleared = bricks.every(row => row.every(b => !b.visible));
      if (allBricksCleared) handleLevelUp();
    }

    function drawFloatingText() {
      floatingTexts.forEach(txt => {
        ctx.globalAlpha = txt.alpha;
        ctx.font = txt.shatter ? 'bold 28px monospace' : 'bold 22px monospace';
        ctx.fillStyle = 'black';
        ctx.fillText(txt.text, txt.x, txt.y);
        txt.y -= (txt.shatter ? 1.5 : 1) * txt.alpha;
        txt.alpha -= txt.shatter ? 0.02 : 0.01;
        if (txt.shatter) txt.x += Math.random() > 0.5 ? 1 : -1;
      });
      floatingTexts = floatingTexts.filter(t => t.alpha > 0);
      ctx.globalAlpha = 1;
    }

    function draw() {
      ctx.clearRect(0, 0, WIDTH, HEIGHT);
      drawParticles();
      drawPaddle();
      drawBall();
      drawBricks();
      drawScore();
      drawFloatingText();
    }

    function update() {
      if (!gameStarted || gameOver) return;
      if (!isPaused) {
        movePaddle();
        moveBall();
        updateParticles();
      }
      draw();
      requestAnimationFrame(update);
    }

    function startGame() {
      paddle.x = WIDTH / 2 - paddle.width / 2;
      paddle.y = HEIGHT - 30;
      ball.x = WIDTH / 2;
      ball.y = HEIGHT - 60;
      createBricks();
      canvas.focus();
      gameStarted = true;
      isPaused = false;
      update();
    }

    function endGame() {
      gameOver = true;
      document.getElementById('endScreen').style.display = 'flex';
      document.getElementById('finalScore').textContent = `Final Score: ${score}`;
    }

    function resetBallAndPaddle() {
      ball.x = WIDTH / 2;
      ball.y = HEIGHT - 60;
      paddle.x = WIDTH / 2 - paddle.width / 2;
    }

    function handleLevelUp() {
      if (level < maxLevel) {
        level++;
        ball.speed += 2;
        ball.dx = ball.speed * (ball.dx > 0 ? 1 : -1);
        ball.dy = -ball.speed;
        brick.rowCount++;
        createBricks();
        resetBallAndPaddle();
      } else {
        endGame();
      }
    }

    function keyDown(e) {
      if (e.key === 'ArrowRight' || e.key === 'Right') paddle.dx = paddle.speed;
      else if (e.key === 'ArrowLeft' || e.key === 'Left') paddle.dx = -paddle.speed;
    }

    function keyUp(e) {
      if (["Right", "ArrowRight", "Left", "ArrowLeft"].includes(e.key)) paddle.dx = 0;
    }

    document.addEventListener('keydown', keyDown);
    document.addEventListener('keyup', keyUp);
    document.getElementById('startScreen').addEventListener('click', () => {
      document.getElementById('startScreen').style.display = 'none';
      startGame();
    });

    canvas.addEventListener('touchstart', e => {
      const touchX = e.touches[0].clientX;
      paddle.dx = touchX > WIDTH / 2 ? paddle.speed : -paddle.speed;
    });
    canvas.addEventListener('touchend', e => {
      paddle.dx = 0;
    });
  </script>
</body>
</html>
