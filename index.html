<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Breakout of Time v1.6</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; width: 100%;
      background: transparent;
      overflow: hidden;
      font-family: monospace;
    }
    * {
      font-family: monospace;
    }
    #canvas-wrapper {
      position: absolute; inset: 0;
      background: transparent;
      border: 1px solid #000;
      box-sizing: border-box;
      transition: transform 0.1s;
    }
    canvas {
      width: 100%; height: 100%;
      display: block;
      background: transparent;
      transition: background 0.05s;
    }
    #overlay {
      position: absolute; inset: 0;
      background: #fff; color: #000;
      font-size: 1.5rem; white-space: pre;
      display: flex; flex-direction: column;
      justify-content: center; align-items: flex-start;
      padding: 2rem; box-sizing: border-box;
      z-index: 20;
      opacity: 1;
      transition: opacity 0.6s ease;
    }
    @keyframes blink { 50% { opacity: 0; } }
    .cursor {
      display: inline-block; width: 0.6ch;
      background: #000; margin-left: 2px;
      animation: blink 1s steps(1) infinite;
      vertical-align: bottom;
    }
    #start-button {
      margin-top: 1rem;
      background: none; border: 1px solid #000;
      padding: 0.5rem 1rem;
      font-size: 1.25rem; color: #000;
      cursor: pointer; display: none;
    }
    #start-button:hover { opacity: 0.8; }
    #timer {
      position: absolute; top: 10px; left: 10px;
      background: rgba(255,255,255,0.8);
      padding: 6px 12px; border-radius: 4px;
      font-size: 1.5rem; color: #000;
      display: none; z-index: 10;
    }
    #timebar {
      position: absolute; top: 0; left: 0;
      height: 4px; background: #000;
      z-index: 9;
      transition: width 0.1s linear;
    }
    #center-popup {
      position: absolute; top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      font-size: 2.5rem; color: #000;
      opacity: 0; transition: opacity 0.5s ease-out;
      pointer-events: none; z-index: 15;
    }
    #left-control, #right-control {
      position: absolute; top: 0; height: 100%; width: 60%;
      z-index: 5; touch-action: none; opacity: 0.1;
    }
    #left-control { left: 0; }
    #right-control { right: 0; }
    #left-control::before, #right-control::before {
      content: '';
      position: absolute; top: 50%;
      font-size: 3rem; opacity: 0.3;
      pointer-events: none;
    }
    #left-control::before {
      content: 'â—€'; left: 20%; transform: translateY(-50%);
    }
    #right-control::before {
      content: 'â–¶'; right: 20%; transform: translateY(-50%);
    }
  </style>
</head>
<body>
  <div id="canvas-wrapper">
    <canvas id="breakout"></canvas>
    <div id="timebar"></div>
    <div id="timer">Time: 30.00s</div>
    <div id="center-popup"></div>
    <div id="left-control"></div>
    <div id="right-control"></div>
    <div id="overlay">
      <div id="boot-text"></div><span class="cursor"></span>
      <button id="start-button">Start</button>
    </div>
  </div>
  <script>
    const lines = [
      'Breakout of Time v1.6 â€” Blackout Edition', '',
      'â† / â†’ to shuffle your regrets',
      'Destroy bricks, not your self-esteem',
      '+1s per brick â€” because apparently you need a reward for basic effort', '',
      'Click Start to pretend this means something.'
    ];

    let lineIndex = 0, charIndex = 0;
    const overlay      = document.getElementById('overlay'),
          bootText     = document.getElementById('boot-text'),
          cursor       = document.querySelector('.cursor'),
          startBtn     = document.getElementById('start-button'),
          timerEl      = document.getElementById('timer'),
          timebar      = document.getElementById('timebar'),
          popup        = document.getElementById('center-popup'),
          leftControl  = document.getElementById('left-control'),
          rightControl = document.getElementById('right-control'),
          canvas       = document.getElementById('breakout'),
          wrapper      = document.getElementById('canvas-wrapper'),
          ctx          = canvas.getContext('2d');

    cursor.style.display = 'none';
    function typeNextChar() {
      if (lineIndex >= lines.length) {
        cursor.style.display = 'inline-block';
        startBtn.style.display = 'inline-block';
        return;
      }
      const line = lines[lineIndex];
      if (charIndex < line.length) {
        bootText.textContent += line.charAt(charIndex++);
      } else {
        bootText.textContent += '\n';
        lineIndex++; charIndex = 0;
      }
      setTimeout(typeNextChar, charIndex === 0 ? 300 : 50);
    }
    typeNextChar();

    let running = false, remainingTime = 30.0, timerInterval;
    const rows = 4, cols = 10, padding = 8;
    let bricks = [], ballTrail = [], particles = [];

    const paddle = { x:0, y:0, width:0, height:10, dx:0, speed:6 },
          ball   = { x:0, y:0, radius:6, dx:4, dy:-4 };

    // ðŸ–¤ Shades of black for brick tones
    const brickColors = ['#2e2e2e', '#1e1e1e', '#121212', '#000000'];

    const shake = { x: 0, y: 0, duration: 0 };

    function resizeCanvas() {
      canvas.width  = canvas.clientWidth;
      canvas.height = canvas.clientHeight;
    }
    window.addEventListener('resize', () => { resizeCanvas(); initBricks(); });
    resizeCanvas();

    function initBricks() {
      bricks = [];
      const totalPad = (cols - 1) * padding;
      const bw = (canvas.width - totalPad) / cols;
      paddle.width = bw * 1.2;
      const offsetX = (canvas.width - (bw * cols + totalPad)) / 2;
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          bricks.push({
            x: offsetX + c * (bw + padding),
            y: r * (bw * 0.3 + padding) + 60,
            w: bw, h: bw * 0.3, broken: false,
            color: brickColors[r % brickColors.length]
          });
        }
      }
    }

    function resetEntities() {
      paddle.x = canvas.width / 2 - paddle.width / 2;
      paddle.y = canvas.height - 30;
      ball.x = canvas.width / 2;
      ball.y = canvas.height - 50;
      ball.dx = 4; ball.dy = -4;
      ballTrail = [];
      particles = [];
      shake.duration = 0;
    }

    function showPopup(text) {
      popup.textContent = text;
      popup.style.opacity = '1';
      setTimeout(() => popup.style.opacity = '0', 800);
    }

    function flashCanvas() {
      canvas.style.background = 'rgba(255,255,255,0.1)';
      setTimeout(() => canvas.style.background = 'transparent', 50);
    }

    function createParticles(x, y, color) {
      for (let i = 0; i < 14; i++) {
        particles.push({
          x, y,
          dx: (Math.random() - 0.5) * 3,
          dy: (Math.random() - 1.5) * 3,
          size: 3 + Math.random() * 2,
          color,
          life: 40,
          gravity: 0.15
        });
      }
    }

    function shakeCanvas() {
      if (shake.duration > 0) {
        shake.x = (Math.random() - 0.5) * 6;
        shake.y = (Math.random() - 0.5) * 6;
        wrapper.style.transform = `translate(${shake.x}px, ${shake.y}px)`;
        shake.duration--;
      } else {
        wrapper.style.transform = 'translate(0, 0)';
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ballTrail.forEach((p, i) => {
        ctx.beginPath();
        ctx.globalAlpha = (i + 1) / (ballTrail.length * 2);
        ctx.arc(p.x, p.y, ball.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      });
      ctx.globalAlpha = 1;

      ctx.fillStyle = '#000';
      ctx.fillRect(paddle.x, paddle.y, paddle.width, paddle.height);

      ctx.beginPath();
      ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.closePath();

      bricks.forEach(b => {
        if (!b.broken) {
          ctx.fillStyle = b.color;
          ctx.fillRect(b.x, b.y, b.w, b.h);
        }
      });

      particles.forEach(p => {
        ctx.globalAlpha = p.life / 40;
        ctx.fillStyle = p.color;
        ctx.fillRect(p.x, p.y, p.size, p.size);
      });
      ctx.globalAlpha = 1;
    }

    function updateGame() {
      if (!running) return;

      paddle.x = Math.max(0, Math.min(canvas.width - paddle.width, paddle.x + paddle.dx));
      ball.x += ball.dx;
      ball.y += ball.dy;

      ballTrail.push({ x: ball.x, y: ball.y });
      if (ballTrail.length > 5) ballTrail.shift();

      let brokenThisFrame = 0;

      if (ball.x < ball.radius || ball.x > canvas.width - ball.radius) ball.dx *= -1;
      if (ball.y < ball.radius) ball.dy *= -1;
      if (ball.y > canvas.height) return endGame('lose');

      if (ball.y + ball.radius >= paddle.y &&
          ball.x >= paddle.x && ball.x <= paddle.x + paddle.width) {
        const hitPos = (ball.x - paddle.x) / paddle.width;
        const angle = (hitPos - 0.5) * Math.PI / 2;
        const speed = Math.sqrt(ball.dx ** 2 + ball.dy ** 2);
        ball.dx = speed * Math.sin(angle);
        ball.dy = -speed * Math.cos(angle);
      }

      for (let b of bricks) {
        if (!b.broken &&
            ball.x > b.x && ball.x < b.x + b.w &&
            ball.y > b.y && ball.y < b.y + b.h) {
          b.broken = true;
          ball.dy *= -1;
          remainingTime += 1;
          createParticles(ball.x, ball.y, b.color);
          brokenThisFrame++;
        }
      }

      if (brokenThisFrame > 0) {
        flashCanvas();
        showPopup(`+${brokenThisFrame}s`);
        if (brokenThisFrame >= 2) shake.duration = 6;
      }

      shakeCanvas();

      particles.forEach(p => {
        p.x += p.dx;
        p.y += p.dy;
        p.dy += p.gravity;
        p.size *= 0.96;
        p.life -= 1;
      });
      particles = particles.filter(p => p.life > 0);

      if (bricks.every(b => b.broken)) return endGame('win');

      draw();
      requestAnimationFrame(updateGame);
    }

    function updateTimer() {
      remainingTime -= 0.1;
      if (remainingTime <= 0) return endGame('lose');
      timerEl.textContent = `Time: ${remainingTime.toFixed(2)}s`;
      const percent = Math.max(0, remainingTime / 30);
      timebar.style.width = `${percent * 100}%`;
    }

    function startGame() {
      initBricks();
      resetEntities();
      remainingTime = 30.0;
      timerEl.textContent = `Time: ${remainingTime.toFixed(2)}s`;
      overlay.style.opacity = 0;
      setTimeout(() => { overlay.style.display = 'none'; }, 600);
      timerEl.style.display = 'block';
      running = true;
      clearInterval(timerInterval);
      timerInterval = setInterval(updateTimer, 100);
      updateGame();
    }

    function endGame(state) {
      running = false;
      clearInterval(timerInterval);
      timerEl.style.display = 'none';
      overlay.style.display = 'flex';
      overlay.style.opacity = 1;

      const message = state === 'win'
        ? 'You won. Somehow. The universe remains unimpressed.'
        : 'You failed. Predictably. Like a moth hitting a brick wall. Repeatedly.';

      overlay.innerHTML = message + '\n';
      startBtn.textContent = 'Try Again?';
      startBtn.style.display = 'inline-block';
      overlay.appendChild(startBtn);
    }

    startBtn.addEventListener('click', startGame);
    document.addEventListener('keydown', e => {
      if (running) {
        if (e.key === 'ArrowLeft')  paddle.dx = -paddle.speed;
        if (e.key === 'ArrowRight') paddle.dx =  paddle.speed;
      }
    });
    document.addEventListener('keyup', e => {
      if (['ArrowLeft','ArrowRight'].includes(e.key)) paddle.dx = 0;
    });

    [leftControl, rightControl].forEach((ctrl, idx) => {
      ctrl.addEventListener('pointerdown', () => {
        if (running) paddle.dx = idx === 0 ? -paddle.speed : paddle.speed;
      });
      ctrl.addEventListener('pointerup', () => {
        if (running) paddle.dx = 0;
      });
      ctrl.addEventListener('pointercancel', () => {
        if (running) paddle.dx = 0;
      });
    });
  </script>
</body>
</html>
